# 正则

*创建于：2020-05-11；更新于：2020-05-11*

在进行表单校验参数校验时，往往需要使用正则；

## 创建方法

- `new RegExp(模式, 修饰符)`‘模式’中允许使用变量，转义需要使用两条反斜线
- `/模式/修饰符`‘模式’中不允许使用变量，转义只需一条反斜线

## 方法

*有无修饰符g修饰，往往会产生不同的结果；*

### 实例方法

- regObj.test(str)对字符串执行搜索；返回值：布尔值（测试 str 中是否存在匹配 regObj 模式的字符串，存在返回 true，不存在返回 false）
- regObj.exec(str)对字符串执行搜索；返回值：如果没有匹配的文本则返回 null，否则返回一个结果数组

### 字符串方法

- str.search(reg）找出首次匹配项的索引
- str.split(reg[,maxLength]) 第一个参数可以是字符串或者正则表达式，它是分隔符；第二个参数可选，限制返回数组的最大长度。
- str.match(reg)找到一个或多个正则表达式的匹配
- str.replace(reg/substr,newStr/function) 第一个参数可以是字符串或者正则表达式，它的作用是匹配。第二个参数可以是字符串(字符串中使用$n对匹配引用)或者函数(参数中可以取到匹配)，它的作用是替换。


## 前瞻后顾

```
// 前瞻：
exp1(?=exp2) 查找exp2前面的exp1
// 后顾：
(?<=exp2)exp1 查找exp2后面的exp1
// 负前瞻：
exp1(?!exp2) 查找后面不是exp2的exp1
// 负后顾：
(?<!exp2)exp1 查找前面不是exp2的exp1
```

## 捕获组与非捕获组

- `()`表示捕获分组，()会把每个分组里的匹配的值保存起来;
- `(?:)`表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来

```javascript
//千分位格式化
"1234567890".replace(/\B(?=(?:\d{3})+(?!\d))/g,",") 
// 结果：1,234,567,890，匹配的是后面是3*n个数字的非单词边界(\B)
```

## 贪婪与非贪婪模式

- 贪婪模式：默认，即尽可能多的匹配到字符。在正则表达式中有表示数量的特殊符号，如`*`,`+`,`？`,`{n,m}`，默认情况下这些符号在匹配时都会尽可能多的去匹配字符，即取数量的上限
- 懒惰模式：尽可能少的匹配到字符，即在匹配时取数量词的下限，问题是如何将贪婪模式转化为懒惰模式，就是在数量词的后面加`?`

![正则](https://gitee.com/gitsdn/img/raw/master/img/20200614145616.png)

## 其他

- [生成流程图](https://regexper.com/)
- [规则参考](https://www.baidufe.com/item/eb10deb92f2c05ca32cf.html)

## 参考

- [正则表达式中?=和?:和?!的理解](https://blog.csdn.net/csm0912/article/details/81206848)
- [正则表达式的一些知识点](https://juejin.im/post/5eb4b3d451882558dc24c366)
- [前端进阶高薪必看-正则篇](https://juejin.im/post/5eb8ad655188256d3c52de29)